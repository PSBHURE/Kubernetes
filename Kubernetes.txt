kind create cluster --name=tes-cluster --config=config.yml

kubectl cluster-info --context kind-tws-cluster

kubectl get nodes --context kind-tws-cluster

kubectl config use-contest kind-tws-cluster

kubectl get ns

kubectl create ns nginx

kubectl get pods -n nginx

kubectl run nginx --image=nginx => for creating pod name as 'nginx'

kubectl delete pod nginx => to delete pod name as 'nginx'

kubectl run nginx --image=nginx:latest -n nginx => pod of nginx name run inside nginx namespace

kubectl delete pod nginx -n nginx => to delete pod inside namespace

kubectl delete ns nginx => to delete namespace

vi namespace.yml
{
kind: Namespace
apiVersion: v1
metadata:
  name: nginx
}

by keyword 'create' it can create only but by keyword 'apply' if not present then created and if present then edited
kubectl apply -f namespace.yml


vi pod.yml
{
kind: Pod
apiVersion: v1
metadata:
  name: nginx-pod
  namespace: nginx
spec:
  containers:
    - name: nginx
	  image: nginx:latest
	  ports:
	  - containerPort: 80
}
kubectl apply -f pod.yml


kubectl exec -it pod/nginx-pod -n nginx -- bash => This command is used to enter  inside a container which is running inside pod and that pod run inside namespace

kubectl describe pod/nginx-pod -n nginx


vi deployement.yml
{
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  namespace: nginx
spec: 
  replicas: 2
  selector:
    matchLabels:
	  app: nginx
	  
  template:
    metadata:
	  name: nginx-dep-pod
	  labels:
	    app: nginx
	
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
	    - containerPort: 80
}
kubectl apply -f deployement.yml

kubectl scale deployment/nginx-deployment -n nginx --replicas=5

kubectl set image deployement/nginx-deployment -n nginx nginx=nginx:1.27.3


vi replicaset.yml
{
kind: ReplicaSet
apiVersion: apps/v1
metadata:
  name: nginx-replicasets
  namespace: nginx
spec: 
  replicas: 2
  selector:
    matchLabels:
	  app: nginx
	  
  template:
    metadata:
	  name: nginx-rep-pod
	  labels:
	    app: nginx
	
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
	    - containerPort: 80
}
kubectl apply -f replicaset.yml

kubectl get ns

kubectl create ns nginx

kubectl get pods -n nginx

kubectl run nginx --image=nginx => for creating pod name as 'nginx'

kubectl delete pod nginx => to delete pod name as 'nginx'

kubectl run nginx -n nginx => pod of nginx name run inside nginx namespace

kubectl delete pod nginx -n nginx => to delete pod inside namespace

kubectl delete ns nginx => to delete namespace

vi namespace.yml
{
kind: Namespace
apiVersion: v1
metadata:
  name: nginx
}

by keyword 'create' it can create only but by keyword 'apply' if not present then created and if present then edited
kubectl apply -f namespace.yml


vi pod.yml
{
kind: Pod
apiVersion: v1
metadata:
  name: nginx-pod
  namespace: nginx
spec:
  containers:
    - name: nginx
	  image: nginx:latest
	  ports:
	  - containerPort: 80
}
kubectl apply -f pod.yml


kubectl exec -it pod/nginx-pod -n nginx -- bash => This command is used to enter  inside a container which is running inside pod and that pod run inside namespace


vi job.yml
{
kind: Job
apiVersion: batch/v1
metadata:
  name: demo-job
  namespace: nginx
spec:
  completions: 1
  parallelism: 1
  template:
    metadata:
	 name: demo-job-pod
	 labels:
	   app: batch-task
	spec:
	  containers:
	  - name: batch-container
	    image:  busybox
		command: ["sh", "-c", "echo Hello Dosto! && sleep 10"]
	  restartPolicy: Never
}
kubectl apply job.yml
kubectl get job -n nginx
kubectl get pods -n nginx
kubectl logs pod/demo-job-qqrkh -n nginx




vi cronjob.yml
{
kind: CronJob
apiVersion: batch/v1
metadata:
  name: minute-backup
  namespace: nginx
spec:
  schedule: "* * * * *"
  jobTemplate:
    spec:
      template:
        metadata:
          name: minute-backup
          labels:
            app: minute-backup
        spec:
          containers:
            - name: batch-container
              image: busybox
              command:
                - sh
                - -c
                - >
                  echo "Backup Started" &&
                  mkdir -p /backups &&
                  mkdir -p /demo-data &&
                  cp -r /demo-data /backups &&
                  echo "Backup Completed"
              volumeMounts:
                - name: data-volume
                  mountPath: /demo-data
                - name: backup-volume
                  mountPath: /backups
          restartPolicy: OnFailure
      volumes:
        - name: data-volume
          hostPath:
            path: /demo-data
            type: DirectoryOrCreate
        - name: backup-volume
          hostPath:
            path: /backups
            type: DirectoryOrCreate
}

vi PersistentVolume.yml
{
kind: PersistentVolume
apiVersion: v1
metadata:
  name: local-pv
  namespace: nginx
  labels:
    app: local
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  hostPath: 
    path: /mnt/data
}
kubectl apply -f PersistentVolume.yml
kubectl get pv


vi PersistentVolumeClaim.yml
{
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-pvc
  namespace: nginx
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
	  storage: 1Gi
  storageClassName: local-storage
}
kubectl apply -f PersistentVolumeClaim.yml
kubectl get pvc



vi deployement.yml   => aading volumeMounts,volumes
{
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  namespace: nginx
spec: 
  replicas: 2
  selector:
    matchLabels:
	  app: nginx
	  
  template:
    metadata:
	  name: nginx-dep-pod
	  labels:
	    app: nginx
	
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
	    - containerPort: 80
		volumeMounts:
		- mountPath: /var/www/html
		  name: my-volume
	  volumes:
	    - name: my-volume
		  persistentVolumeClaim:
		    claimName: local-pvc
		
		  
}


vi service.yml
{
kind: Service
apiVersion: v1
metadata:
  name: nginx-service
  namespace: nginx
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
	  port: 80
	  targetPort: 80
  type: ClusterIP					=> This is type of service
}
kubectl apply -f service.yml
kubectl get svc -n nginx


kubectl getall -n nginx

sudo -E kubectl port-forward service/nginx-service -n nginx 81:80 --address=0.0.0.0
sudo -E kubectl port-forward service/notes-app-service -n notes-app 8000:8000 --address=0.0.0.0

++++++++++++++++++++++++++++++for MYSQL start++++++++++++++++++++++++++++++++++++++
ubuntu@Kubernetes:~/mysql$ cat namespace.yml
kind: Namespace
apiVersion: v1
metadata:
  name: mysql


ubuntu@Kubernetes:~/mysql$ cat configMap.yml
kind: ConfigMap
apiVersion: v1
metadata:
  name: mysql-config-map
  namespace: mysql
data:
  MYSQL_DATABASE: devops



ubuntu@Kubernetes:~/mysql$ cat secrate.yml
kind: Secret
apiVersion: v1
metadata:
  name: mysql-secret
  namespace: mysql
data:
  MYSQL_ROOT_PASSWORD: cm9vdAo=  #base64 encoded for "root"


ubuntu@Kubernetes:~/mysql$ cat statefulset.yml
kind: StatefulSet
apiVersion: apps/v1
metadata:
  name: mysql-statefulset
  namespace: mysql
spec:
  serviceName: mysql-service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_ROOT_PASSWORD

        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config-map
              key: MYSQL_DATABASE
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
    - metadata:
        name: mysql-data
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 1Gi



ubuntu@Kubernetes:~/mysql$ cat service.yml
kind: Service
apiVersion: v1
metadata:
  name: mysql-service
  namespace: mysql
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - name: mysql
    protocol: TCP
    port: 3306
    targetPort: 3306





++++++++++++++++++++++++++++++for MYSQL end++++++++++++++++++++++++++++++++++++++



kubectl taint node tws-cluster-worker2 prod=true:NoSchedule => mean on this node now pods can not created

kubectl taint node tws-cluster-worker2 pod=true:NoSchedule- => mean on this node now pods can created i.e. "taint" is removed.


vi pod.yml
{
kind: Pod
apiVersion: v1
metadata:
  name: nginx-pod
  namespace: nginx
spec:
  containers:
    - name: nginx
	  image: nginx:latest
	  ports:
	  - containerPort: 80
	tolerations:					=> because of this even this node is "taint" it will allow to run pod on that node
	  - key: "prod"
	    operator: "Equal"
		value: "true"
		effect: "NoSchedule"
}
kubectl apply -f pod.yml


RUN FOLLOWING COMMAND TO INSATLL MATRIX-SERVER IN OUR KIND Cluster
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

kubectl -n kube-system edit deployment metrics-server 

add the security bypass to deployment under container.args
- --kubelet-insecure-tls
- --kubelet-preferred-address-types=InternalIP,Hostname,ExternalIP

RESTART TJE METRICS-SERVER
kubectl -n kube-system rollout restart deployment metrics-server

kubectl top node => show the usage of  nodes

kubectl top pod -n nginx => to check how much resources used by pods of perticular namespace 





